/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "ftp.h"

int pid;

// Funkcja obslugujaca pobieranie pliku od klienta
int *
wysylaniepliku_1_svc(dane *argp, struct svc_req *rqstp)
{
	static int  result;
	
	// Utworzenie procesu potomnego 
	pid=fork();
	
	// Sprawdzenie czy udalo sie utworzyc proces potomny
	if(pid == 0){

		// Pobranie id procesu
		int id = getpid();

		// Utworzenie zmiennych do obslugi pobierania
		char bufor[1024];
		char nazwaPliku[30];
		int wielkoscPliku;
		int licznik;
		memset(bufor, 0, 1024);
		memset(nazwaPliku, 0, 30);
		
		// Odebranie danych przychodzacych od klienta
		strcpy(bufor,argp->przesylaneDane);
		strcpy(nazwaPliku,argp->nazwaPliku);
		wielkoscPliku = argp->wielkoscPliku;
		licznik = argp->licznik;
		
		// Otwarcie pliku w trybie binarnym umozliwajacym dodawanie kolejnych danych
		FILE *fplik = fopen(nazwaPliku,"ab");

		// Uspienie watku w celu lepszego pokazania wspolbieznosci
		sleep(1);

		// Sprawdzenie czy odebrac pelny bufor czy tylko fragment
		if((licznik +1) * 1024 < wielkoscPliku){
			fwrite(bufor, 1024, 1, fplik);
		} else{
			fwrite(bufor, (wielkoscPliku%1024), 1, fplik);
		}

		// Wyswietlenie informacji o pobieranym pliku
		printf("[%d] Trwa pobieranie pliku: '%s'\n", id, nazwaPliku);
		
		//zamkniecie pliku
		fclose(fplik);

		// Przypisanie do zwracanego wyniku 1 - prawidlowo odebrano dane
		result = 1;

		// Zwrocenie wartosci
		return &result;
		exit(0);
	}

	// Sprawdzenie czy nie udalo sie utworzyc procesu potmnego
	if(pid < 0){
	   	printf("Nie udało sie utworzyc nowego procesu\n");

	   	// Przypisanie do zwracanego wyniku 0 - nie odebrano danych
	   	result = 0;

	   	// Zwrocenie wartosci
	   	return &result;
	   	exit(1);
	}	
}


// Funkcja zwracajaca rozmiar pliku znajdujacego sie na serwerze
int *
rozmiarpliku_1_svc(pobranieNazwy *argp, struct svc_req *rqstp)
{
	static int  result;

	// Pobranie nazwy pliku od klienta
	char nazwaPliku[30];
	strcpy(nazwaPliku,argp->nazwaPliku);

	printf("Trwa obliczanie rozmiaru pliku '%s' \n", nazwaPliku);

	// Obliczenie rozmiaru pliku
	FILE *fplik = fopen(nazwaPliku, "rb");
	fseek(fplik, 0, SEEK_END);
	result = ftell(fplik);
	fseek(fplik, 0, SEEK_SET);
	fclose(fplik);

	// Zwrocenie rozmiaru pliku
	return &result;
}

// Funkcja zwracajaca informacje czy plik znajduje sie na swererze
int *
czyplikistnieje_1_svc(pobranieNazwy *argp, struct svc_req *rqstp)
{
	static int  result;

	// Pobranie nazwy pliku od klienta
	char nazwaPliku[30];
	strcpy(nazwaPliku,argp->nazwaPliku);
	printf("Trwa sprawdzenie czy plik '%s' znajduje sie na serwerze\n", nazwaPliku);

	// Sprawdzenie czy plik istnieje
	FILE *fplik = fopen(nazwaPliku, "rb");
	if( !fplik )
	{
		//Zwrocenie do klienta wartosci 0 - plik nie istnieje
		result = 0; 
		return &result;
	}else{
		//Zwrocenie do klienta wartosci 1 - plik istnieje
		fclose(fplik);
		result = 1;
	}

	return &result;
}

// Funkcja obslugujaca wysylanie pliku do klienta
dane *
pobieraniepliku_1_svc(daneKontrolne *argp, struct svc_req *rqstp)
{
	static dane  result;
	
	// Utworzenie procesu potomnego 
	pid=fork();
	
	// Sprawdzenie czy udalo sie utworzyc proces potomny
	if(pid == 0){

		// Pobranie id procesu
		int id = getpid();

		char bufor[1024];
		
		// Pobranie nazwy pliku
		char nazwaPliku[30];
		strcpy(nazwaPliku,argp->nazwaPliku);

		// Pobranie informacji ile juz pliku pobral klient
		int pozycja;	
		pozycja = argp->polozenie;
						
		FILE *fplik = fopen(nazwaPliku, "rb");
		fseek(fplik, pozycja, 1);

		//wyslanie pliku do klienta
		printf("[%d] Trwa wysylanie pliku '%s' \n",id, nazwaPliku);
		memset(bufor,0,1024);
		fread(bufor, 1024,1,fplik);
		strcpy(result.przesylaneDane, bufor);	

		// Uspienie watku w celu lepszego pokazania wspolbieznosci
		sleep(1);

		// Zwrocenie wyniku do klienta
		return &result;
		exit(0);
	}

	// Sprawdzenie czy nie udalo sie utworzyc procesu potmnego
	if(pid < 0){
	   	printf("Nie udało sie utworzyc nowego procesu\n");
	   	exit(1);
	}	
}
